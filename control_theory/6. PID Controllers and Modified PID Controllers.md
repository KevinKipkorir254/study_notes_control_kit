# PID CONTROLLERS AND MODIFIED PID CONTROLLERS
## INTRODUCTION

A Proportional-Integral-Derivative (PID) controller is one of the most widely used control algorithms in engineering and industrial applications, prized for its simplicity and effectiveness in managing dynamic systems. At its core, a PID controller aims to minimize the error between a system's desired output and its actual output by continuously adjusting control inputs based on three key terms: Proportional (P), Integral (I), and Derivative (D).

Because most PID controllers are adjusted on-site, various tuning methods have been developed to ensure that these controllers perform optimally across a wide range of systems and conditions. The flexibility of PID control allows for precise adjustments in real-time, adapting to the specific requirements of each application. Numerous tuning rules, such as the Ziegler-Nichols or Cohen-Coon methods, have been proposed in the literature to guide engineers in fine-tuning PID parameters. These tuning methods provide a structured approach for setting gains, either manually or through automated tuning algorithms embedded in modern controllers.

Some PID controllers now incorporate automatic tuning features that allow for real-time parameter adjustment. This capability enables seamless adaptation to changing conditions, which is particularly useful in applications with variable dynamics. Additionally, modified forms of PID control, such as I-PD and multi-degree-of-freedom PID controllers, have been developed to provide even greater flexibility and control accuracy in industrial applications.

Practical strategies, such as bumpless transfer from manual to automatic operation and gain scheduling for systems with variable operating points, have also been widely adopted. These advancements extend PID’s effectiveness in scenarios where model-based design is impractical or impossible due to unknown or complex system dynamics.

The general applicability of PID controllers has made them a cornerstone in control engineering, especially in fields like process control, where exact mathematical models of plants are often unavailable. Here, basic and modified PID schemes have shown their reliability in delivering satisfactory control across diverse applications, even when they may not achieve absolute optimality.

## MOTOR MODEL TO BE USED FOR THE DEMONSTRATION


$$
\frac{Y(s)}{U(s)} = \frac{0.7555}{s² + 13.87s + 34.91}
$$

## ZEIGLER-NICHOLS RULES FOR TUNING PID CONTROLLERS

### FIRST METHOD

This method involves the use of the response of the plant to a unit step, the method applies only if the system step response has an s-curve shape. The shape is described by two constants the delay and the time constant T. They are know by drawing a tangent line with th inflection point as show below.
![ZEIGLER METHOD 1](../extra_files/PID_ZEIGLER_METHOD_1.png)

the point the line crosses the x-axis to the 0, is know as the delay time L The time the system takes to cross the point c(t) = K is the time constant. We then use the table below to calculate the PId coefficients:
| Type of Controller | \( $K_p$ \)     | \( $T_i$ \)        | \( $T_d$ \)    |
|--------------------|-----------------|--------------------|----------------|
| P                  |$\frac{T}{L}$    | $\infty$           |   $0$          |
| PI             | $0.96\frac{T}{L}$   | $\frac{L}{0.3}$    |   $0$          |
| PID                |$1.2\frac{T}{L}$ | $L$                |   $0.5L$       |


Given our system we can estimate it by a simple arduino sketch:

```arduino
//OBTAINING THE DATA FEEDBACK
    //filtering the data 
    double yn = 0.969 * yn_1 + 0.0155 * velocity + 0.0155 * xn_1;
    xn_1 = velocity;
    yn_1 = yn;

    //velocity time
    current_position = ((float)encoderCount / 500) * 3.147;
    velocity = (current_position - radians_)/(0.01);   
    radians_ = current_position; 
    
      int feed = 150;//random K value
      ledcWrite(0, feed);
        if(255 > 0)
        {
           digitalWrite(IN1, HIGH);
           digitalWrite(IN2, LOW);
        }
        else if(255 < 0)
        {
           digitalWrite(IN2, HIGH);
           digitalWrite(IN1, LOW);
        }
    

    Serial.println(yn);

    delay(10);
```
Basically what we do is give the system a certain PWM value and monitor the output velocity value. From the output data, we can graph that, for our system the data is as follows:

![ZEIGLER NICHOLS OUTPUT](../extra_files/ZEIGLER_NICHOLS_METHOD_1_OUTPUT.png)

The data output file is linked below:

[OUTPUT DATA](../extra_files/ARDUINO_SCRIPTS/PID_zeigler_nichols_method_1/Zeigler_nichols_method_1.xlsx)

Each data point is collected every 0.01 seconds. After drawing th tanget line we greater

$$ L \approx 0.07s $$

$$ T \approx 0.36s $$

The PID coefficients are therefor

**Proportional Control**

$$k_P = \frac{0.36}{0.07}$$

$$T_i = \infty$$

$$T_d = 0$$

**Proportional Integral Control**

$$k_P = 0.9*\frac{0.36}{0.07}$$

$$T_i = \frac{0.07}{0.3}$$

$$T_d = 0$$

**Proportional Integral Derivative Control**

$$k_P = 1.2*\frac{0.36}{0.07}$$

$$T_i = 2*0.07$$

$$T_d = 0.5*0.07$$

The control loop is:

![CONTROL LOOP](../extra_files/CONTROL%20LOOP.png)

The $\infty$ is in practice a large number. To represent this in Cpp for arduino we have to convert the continuous time system to discrete time we can use matlab for this:

```matlab
T = 0.36;
L = 0.07;

K_p = (T/L); 
T_i = 1000000; 
T_d = 0;

num = [K_p*T_d*T_i  K_p*T_i K_p];
den = [T_i 0];
fs = 100;%%meaning after every 10ms

tf_t = tf( num, den)

sample_time = 0.01;
tf_d = c2d(tf_t, sample_time, 'tustin')
K_p = 0.9*(T/L); 
T_i = (L/0.3); 
T_d = 0;

num = [K_p*T_d*T_i  K_p*T_i K_p];
den = [T_i 0];
fs = 100;%%meaning after every 10ms

tf_t = tf( num, den);

sample_time = 0.01;
tf_d = c2d(tf_t, sample_time, 'tustin')
K_p = 1.2*(T/L); 
T_i = (L); 
T_d = 0.5*L;

num = [K_p*T_d*T_i  K_p*T_i K_p];
den = [T_i 0];
fs = 100;%%meaning after every 10ms

tf_t = tf( num, den);

sample_time = 0.01;
tf_d = c2d(tf_t, sample_time, 'tustin')
```

Ther results we get from these are:

For P:

$$\frac{5.143*z - 5.143}{z-1} $$

For PI:

$$\frac{4.728*z-4.529}{z-1}$$

For PID:

$$\frac{49.81*z^{2}-85.52*z+37.47}{z^{2}-1}$$

After transformation we get:

For P:

$$y[k] = y[k-1]+5.143*u[k]-5.143*u[k-1]$$

For PI:

$$y[k] = y[k-1]+4.728*u[k]-4.529*u[k-1]$$

For PID:

$$y[k] = y[k-2]+49.81*u[k]-85.52*u[k-1]+37.47*u[k-2]$$

#### ARDUINO IMPLEMENTATIONS
**FOR THE P CONTROLLER**

```arduino
//DATA STORAGE
double controller_input[3] = { 0.0, 0.0, 0.0};//u[k], u[k-1], u[k-2]
double controller_output[3] = { 0.0, 0.0, 0.0};//y[k], y[k-1], y[k-2]

//coefficient storage
double output_coeffs[2] = { 1.0, 1.0};//output coeffs y[k], y[k-1]
double input_coeffs[2] = { 5.143, -5.143};//input coeffs, u[], u[k-1]
```

In the for loop the controller is implemented as:

```arduino
    //computing the error
    double ref = 2.5;
    double error = ref - yn;


    //computing the controller values
    //replacing the values
    controller_input[0] = error;
    controller_output[0] = controller_output[1] + input_coeffs[0]*controller_input[0] + input_coeffs[1]*controller_input[1];
    controller_input[1] = controller_input[0];
    controller_output[1] = controller_output[0];
```

The gain did not even budge it from zero.

**FOR THE PI CONTROLLER**

```arduino
//DATA STORAGE
double controller_input[3] = { 0.0, 0.0, 0.0};//u[k], u[k-1], u[k-2]
double controller_output[3] = { 0.0, 0.0, 0.0};//y[k], y[k-1], y[k-2]

//coefficient storage
double output_coeffs[2] = { 1.0, 1.0};//output coeffs y[k], y[k-1]
double input_coeffs[2] = { 4.728, -4.529};//input coeffs, u[k], u[k-1]
```


In the loop the controller is implemented as:

```arduino
    //computing the error
    double ref = 2.5;
    double error = ref - yn;


    //computing the controller values
    //replacing the values
    controller_input[0] = error;
    controller_output[0] =  output_coeffs[1]*controller_output[1] + input_coeffs[0]*controller_input[0] + input_coeffs[1]*controller_input[1];
    controller_input[1] = controller_input[0];
    controller_output[1] = controller_output[0];
```

![PI OUTPUT](../extra_files/Z_N_PI.png)


**FOR THE PID CONTROLLER**

For the initialization

```arduino
//DATA STORAGE
double controller_input[3] = { 0.0, 0.0, 0.0};//u[k], u[k-1], u[k-2]
double controller_output[3] = { 0.0, 0.0, 0.0};//y[k], y[k-1], y[k-2]

//coefficient storage
double output_coeffs[3] = { 1.0, 0.0, 1.0};//output coeffs y[k], y[k-1], y[k-2]
double input_coeffs[3] = { 49.81, -85.52, 37.47};//input coeffs, u[k], u[k-1], u[k-2]
```
The loop is implemented as follows:

```arduino
    //replacing the values
    //computing the error
    double ref = 2.5;
    double error = ref - yn;

    controller_input[0] = error;
    controller_output[0] =  output_coeffs[1]*controller_output[1] + output_coeffs[2]*controller_output[2] + input_coeffs[0]*controller_input[0] + input_coeffs[1]*controller_input[1] +  input_coeffs[2]*controller_input[2];
    controller_input[2] = controller_input[1];
    controller_input[1] = controller_input[0];
    controller_output[2] = controller_output[1];
    controller_output[1] = controller_output[0];
```

![PID DATA](../extra_files/Z_N_PID.png)